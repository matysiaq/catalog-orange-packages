apiVersion: v1
kind: ConfigMap
metadata:
  name: cnos-kibana-config
  labels:
    app: cnos-kibana
  namespace: cnos-system
data:
  kibana.yml: "xpack.fleet.packages:\n- name: apm\n  version: 8.13.0\n\n  \n"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cnos-kibana-helm-scripts
  labels:
    app: cnos-kibana
  namespace: cnos-system
data:
  manage-es-token.js: "const https = require('https');\nconst fs = require('fs');\n\n// Read environment variables\nfunction getEnvVar(name) {\n    if (!process.env[name]) {\n        throw new Error(name + ' environment variable is missing')\n    }\n    return process.env[name]\n}\n\n// Elasticsearch API\nconst esPath = '_security/service/elastic/kibana/credential/token/kibana';\nconst esUrl = 'https://cnos-elasticsearch-master:9200' + '/' + esPath\nconst esUsername = getEnvVar('ELASTICSEARCH_USERNAME');\nconst esPassword = getEnvVar('ELASTICSEARCH_PASSWORD');\nconst esAuth = esUsername + ':' + esPassword;\nconst esCaFile = getEnvVar('ELASTICSEARCH_SSL_CERTIFICATEAUTHORITIES');\nconst esCa = fs.readFileSync(esCaFile);\n\n// Kubernetes API\nconst k8sHostname = getEnvVar('KUBERNETES_SERVICE_HOST');\nconst k8sPort = getEnvVar('KUBERNETES_SERVICE_PORT_HTTPS');\nconst k8sPostSecretPath = 'api/v1/namespaces/cnos-system/secrets';\nconst k8sDeleteSecretPath = 'api/v1/namespaces/cnos-system/secrets/cnos-kibana-es-token';\nconst k8sPostSecretUrl = `https://${k8sHostname}:${k8sPort}/${k8sPostSecretPath}`;\nconst k8sDeleteSecretUrl = `https://${k8sHostname}:${k8sPort}/${k8sDeleteSecretPath}`;\nconst k8sBearer = fs.readFileSync('/run/secrets/kubernetes.io/serviceaccount/token');\nconst k8sCa = fs.readFileSync('/run/secrets/kubernetes.io/serviceaccount/ca.crt');\n\n// Post Data\nconst esTokenDeleteOptions = {\n    method: 'DELETE',\n    auth: esAuth,\n    ca: esCa,\n};\nconst esTokenCreateOptions = {\n    method: 'POST',\n    auth: esAuth,\n    ca: esCa,\n};\nconst secretCreateOptions = {\n    method: 'POST',\n    ca: k8sCa,\n    headers: {\n        'Authorization': 'Bearer ' + k8sBearer,\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n    }\n};\nconst secretDeleteOptions = {\n    method: 'DELETE',\n    ca: k8sCa,\n    headers: {\n        'Authorization': 'Bearer ' + k8sBearer,\n        'Accept': 'application/json',\n        'Content-Type': 'application/json',\n    }\n};\n\n// With thanks to https://stackoverflow.com/questions/57332374/how-to-chain-http-request\nfunction requestPromise(url, httpsOptions, extraOptions = {}) {\n    return new Promise((resolve, reject) => {\n        const request = https.request(url, httpsOptions, response => {\n            \n            console.log('statusCode:', response.statusCode);\n            \n            let isSuccess = undefined;\n            \n            if (typeof(extraOptions.extraStatusCode) != \"undefined\" && extraOptions.extraStatusCode != null) {\n                isSuccess = response.statusCode >= 200 && response.statusCode < 300 || response.statusCode == extraOptions.extraStatusCode;\n            } else {\n                isSuccess = response.statusCode >= 200 && response.statusCode < 300;\n            }\n            \n            let data = '';\n            response.on('data', chunk => data += chunk); // accumulate data\n            response.once('end', () => isSuccess ? resolve(data) : reject(data));  // resolve promise here\n        });\n        \n        request.once('error', err => {\n            // This won't log anything for e.g. an HTTP 404 or 500 response,\n            // since from HTTP's point-of-view we successfully received a\n            // response.\n            console.log(`${httpsOptions.method} ${httpsOptions.path} failed: `, err.message || err);\n            reject(err);  // if promise is not already resolved, then we can reject it here\n        });\n        \n        if (typeof(extraOptions.payload) != \"undefined\") {\n            request.write(extraOptions.payload);\n        }\n        request.end();\n    });\n}\n\nfunction createEsToken() {\n    // Chaining requests\n    console.log('Cleaning previous token');\n    // 404 status code is accepted if there is no previous token to clean\n    return requestPromise(esUrl, esTokenDeleteOptions, {extraStatusCode: 404}).then(() => {\n        console.log('Creating new token');\n        return requestPromise(esUrl, esTokenCreateOptions).then(response => {\n            const body = JSON.parse(response);\n            const token = body.token.value\n            \n            // Encode the token in base64\n            const base64Token = Buffer.from(token, 'utf8').toString('base64');\n            \n            // Prepare the k8s secret\n            const secretData = JSON.stringify({\n                \"apiVersion\": \"v1\",\n                \"kind\": \"Secret\",\n                \"metadata\": {\n                    \"namespace\": \"cnos-system\",\n                    \"name\": \"cnos-kibana-es-token\",\n                },\n                \"type\": \"Opaque\",\n                \"data\": {\n                    \"token\": base64Token,\n                }\n            })\n            \n            // Create the k8s secret\n            console.log('Creating K8S secret');\n            return requestPromise(k8sPostSecretUrl, secretCreateOptions, {payload: secretData})\n        });\n    });\n}\n\nfunction cleanEsToken() {\n    // Chaining requests\n    console.log('Cleaning token');\n    return requestPromise(esUrl, esTokenDeleteOptions).then(() => {\n        // Create the k8s secret\n        console.log('Delete K8S secret');\n        return requestPromise(k8sDeleteSecretUrl, secretDeleteOptions)\n    });\n}\n\nconst command = process.argv[2];\nswitch (command) {\n    case 'create':\n        console.log('Creating a new Elasticsearch token for Kibana')\n        createEsToken().catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n        break;\n    case 'clean':\n        console.log('Cleaning the Kibana Elasticsearch token')\n        cleanEsToken().catch(err => {\n            console.error(err);\n            process.exit(1);\n        });\n        break;\n    default:\n        console.log('Unknown command');\n        process.exit(1);\n}\n"
